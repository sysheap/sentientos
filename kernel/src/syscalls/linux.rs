use crate::{
    autogenerated::userspace_programs::PROGRAMS,
    cpu::Cpu,
    debug,
    klibc::{
        consumable_buffer::ConsumableBuffer,
        elf::ElfFile,
        util::{ByteInterpretable, UsizeExt},
    },
    memory::{PAGE_SIZE, PhysAddr, VirtAddr, page::Pages, page_tables::XWRMode},
    net::{self, arp, sockets::Port, udp::UdpHeader},
    print, println,
    processes::{
        brk::Brk,
        fd_table::{FdFlags, FileDescriptor},
        loader,
        process::{Process, ProcessRef},
        process_table,
        thread::{Thread, ThreadRef, VforkState, VforkWait, get_next_tid},
        timer,
        userspace_ptr::UserspacePtr,
        wait_child::WaitChild,
    },
    syscalls::macros::linux_syscalls,
};
use alloc::{string::String, sync::Arc, vec::Vec};
use common::{
    ioctl::{SENTIENT_LIST_PROGRAMS, SENTIENT_PANIC},
    pid::Tid,
    syscalls::trap_frame::{Register, TrapFrame},
};
use core::ffi::{c_int, c_uint, c_ulong};
use headers::{
    errno::Errno,
    socket::{AF_INET, SOCK_CLOEXEC, SOCK_DGRAM, sockaddr_in},
    syscall_types::{
        _NSIG, CLOCK_MONOTONIC, CLOCK_REALTIME, CLONE_VFORK, CLONE_VM, F_GETFL, F_SETFL, FIONBIO,
        MAP_ANONYMOUS, MAP_FIXED, MAP_PRIVATE, PROT_EXEC, PROT_NONE, PROT_READ, PROT_WRITE,
        SIG_BLOCK, SIG_SETMASK, SIG_UNBLOCK, SIGCHLD, SIGKILL, SIGSTOP, TIOCGWINSZ, iovec, pollfd,
        sigaction, sigset_t, stack_t, timespec,
    },
};

impl ByteInterpretable for sockaddr_in {}

linux_syscalls! {
    SYSCALL_NR_BIND => bind(fd: c_int, addr: *const u8, addrlen: c_uint);
    SYSCALL_NR_BRK => brk(brk: c_ulong);
    SYSCALL_NR_CLONE => clone(flags: c_ulong, stack: usize, ptid: Option<*mut c_int>, tls: c_ulong, ctid: Option<*mut c_int>);
    SYSCALL_NR_CLOSE => close(fd: c_int);
    SYSCALL_NR_EXECVE => execve(filename: usize, argv: usize, envp: usize);
    SYSCALL_NR_EXIT_GROUP => exit_group(status: c_int);
    SYSCALL_NR_FCNTL => fcntl(fd: c_int, cmd: c_int, arg: c_ulong);
    SYSCALL_NR_GETPPID => getppid();
    SYSCALL_NR_GETTID => gettid();
    SYSCALL_NR_IOCTL => ioctl(fd: c_int, op: c_uint, arg: usize);
    SYSCALL_NR_MMAP => mmap(addr: usize, length: usize, prot: c_uint, flags: c_uint, fd: c_int, offset: isize);
    SYSCALL_NR_MUNMAP => munmap(addr: usize, length: usize);
    SYSCALL_NR_CLOCK_NANOSLEEP => clock_nanosleep(clockid: c_int, flags: c_int, request: *const timespec, remain: Option<*mut timespec>);
    SYSCALL_NR_NANOSLEEP => nanosleep(duration: *const timespec, rem: Option<*const timespec>);
    SYSCALL_NR_PPOLL => ppoll(fds: *mut pollfd, n: c_uint, to: Option<*const timespec>, mask: Option<*const sigset_t>);
    SYSCALL_NR_PRCTL => prctl();
    SYSCALL_NR_READ => read(fd: c_int, buf: *mut u8, count: usize);
    SYSCALL_NR_RECVFROM => recvfrom(fd: c_int, buf: *mut u8, len: usize, flags: c_int, src_addr: Option<*mut u8>, addrlen: Option<*mut c_uint>);
    SYSCALL_NR_RT_SIGACTION => rt_sigaction(sig: c_uint, act: Option<*const sigaction>, oact: Option<*mut sigaction>, sigsetsize: usize);
    SYSCALL_NR_RT_SIGPROCMASK => rt_sigprocmask(how: c_uint, set: Option<*const sigset_t>, oldset: Option<*mut sigset_t>, sigsetsize: usize);
    SYSCALL_NR_SENDTO => sendto(fd: c_int, buf: *const u8, len: usize, flags: c_int, dest_addr: *const u8, addrlen: c_uint);
    SYSCALL_NR_SET_TID_ADDRESS => set_tid_address(tidptr: *mut c_int);
    SYSCALL_NR_SIGALTSTACK => sigaltstack(uss: Option<*const stack_t>, uoss: Option<*mut stack_t>);
    SYSCALL_NR_SOCKET => socket(domain: c_int, typ: c_int, protocol: c_int);
    SYSCALL_NR_WAIT4 => wait4(pid: c_int, status: Option<*mut c_int>, options: c_int, rusage: usize);
    SYSCALL_NR_WRITEV => writev(fd: c_int, iov: *const iovec, iovcnt: c_int);
    SYSCALL_NR_WRITE => write(fd: c_int, buf: *const u8, count: usize);
}

pub struct LinuxSyscallHandler {
    current_process: ProcessRef,
    current_thread: ThreadRef,
    current_tid: Tid,
}

impl LinuxSyscalls for LinuxSyscallHandler {
    async fn read(
        &mut self,
        fd: c_int,
        buf: LinuxUserspaceArg<*mut u8>,
        count: usize,
    ) -> Result<isize, headers::errno::Errno> {
        let (descriptor, flags) = self
            .current_process
            .with_lock(|p| {
                p.fd_table()
                    .get(fd)
                    .map(|e| (e.descriptor.clone(), e.flags))
            })
            .ok_or(Errno::EBADF)?;

        let data = if flags.is_nonblocking() {
            descriptor.try_read(count)?
        } else {
            descriptor.read(count).await?
        };
        assert!(data.len() <= count, "Read more than requested");
        buf.write_slice(&data)?;

        Ok(data.len() as isize)
    }

    async fn write(
        &mut self,
        fd: i32,
        buf: LinuxUserspaceArg<*const u8>,
        count: usize,
    ) -> Result<isize, Errno> {
        let descriptor = self
            .current_process
            .with_lock(|p| p.fd_table().get(fd).map(|e| e.descriptor.clone()))
            .ok_or(Errno::EBADF)?;

        let data = buf.validate_slice(count)?;
        descriptor.write(&data)?;

        Ok(count as isize)
    }

    async fn exit_group(&mut self, status: c_int) -> Result<isize, Errno> {
        Cpu::with_scheduler(|mut s| {
            s.kill_current_process(status);
        });

        debug!("Exit process with status: {status}\n");
        Ok(0)
    }

    async fn set_tid_address(
        &mut self,
        tidptr: LinuxUserspaceArg<*mut c_int>,
    ) -> Result<isize, Errno> {
        self.current_thread.with_lock(|mut t| {
            t.set_clear_child_tid((&tidptr).into());
        });
        Ok(0)
    }

    async fn ppoll(
        &mut self,
        fds: LinuxUserspaceArg<*mut pollfd>,
        n: c_uint,
        to: LinuxUserspaceArg<Option<*const timespec>>,
        mask: LinuxUserspaceArg<Option<*const sigset_t>>,
    ) -> Result<isize, Errno> {
        let mask = mask.validate_ptr()?;

        let old_mask = if let Some(mask) = mask {
            Some(self.current_thread.with_lock(|mut t| t.set_sigset(mask)))
        } else {
            None
        };

        Self::validate_poll_timeout(to.validate_ptr()?);

        let poll_fds = fds.validate_slice(n as usize)?;
        for pfd in &poll_fds {
            self.current_process
                .with_lock(|p| p.fd_table().get(pfd.fd).map(|e| e.descriptor.clone()))
                .ok_or(Errno::EBADF)?;
            assert_eq!(
                pfd.events, 0,
                "No further events are supported at the moment"
            );
        }

        if let Some(mask) = old_mask {
            self.current_thread.with_lock(|mut t| t.set_sigset(mask));
        }

        Ok(0)
    }

    async fn rt_sigaction(
        &mut self,
        sig: c_uint,
        act: LinuxUserspaceArg<Option<*const sigaction>>,
        oact: LinuxUserspaceArg<Option<*mut sigaction>>,
        sigsetsize: usize,
    ) -> Result<isize, Errno> {
        if sigsetsize != core::mem::size_of::<sigset_t>()
            || matches!(sig, SIGKILL | SIGSTOP)
            || sig >= _NSIG
        {
            return Err(Errno::EINVAL);
        }

        let old_act = if let Some(act) = act.validate_ptr()? {
            self.current_thread
                .with_lock(|mut t| t.set_sigaction(sig, act))
        } else {
            self.current_thread.with_lock(|t| t.get_sigaction(sig))
        }?;

        oact.write_if_not_none(old_act)?;

        Ok(0)
    }

    async fn rt_sigprocmask(
        &mut self,
        how: c_uint,
        set: LinuxUserspaceArg<Option<*const sigset_t>>,
        oldset: LinuxUserspaceArg<Option<*mut sigset_t>>,
        sigsetsize: usize,
    ) -> Result<isize, Errno> {
        if sigsetsize != core::mem::size_of::<sigset_t>() {
            return Err(Errno::EINVAL);
        }

        let new_set = set.validate_ptr()?;

        let old_set_in_thread = if let Some(new_set) = new_set {
            self.current_thread.with_lock(|mut t| {
                let mut current_set = t.get_sigset();
                match how {
                    SIG_BLOCK => current_set.sig[0] |= new_set.sig[0],
                    SIG_UNBLOCK => current_set.sig[0] &= !new_set.sig[0],
                    SIG_SETMASK => current_set.sig[0] = new_set.sig[0],
                    _ => {
                        return Err(Errno::EINVAL);
                    }
                }
                Ok(t.set_sigset(current_set))
            })?
        } else {
            self.current_thread.with_lock(|t| t.get_sigset())
        };

        oldset.write_if_not_none(old_set_in_thread)?;

        Ok(0)
    }

    async fn sigaltstack(
        &mut self,
        uss: LinuxUserspaceArg<Option<*const stack_t>>,
        uoss: LinuxUserspaceArg<Option<*mut stack_t>>,
    ) -> Result<isize, Errno> {
        let uss = uss.validate_ptr()?;
        self.current_thread.with_lock(|mut t| {
            let old = t.get_sigaltstack();
            if let Some(uss) = uss {
                t.set_sigaltstack(&uss);
            }
            uoss.write_if_not_none(old)?;
            Ok::<(), Errno>(())
        })?;
        Ok(0)
    }

    fn get_process(&self) -> ProcessRef {
        let process = self.current_process.clone();
        let vfork_parent = process.lock().vfork_parent().cloned();
        vfork_parent.unwrap_or(process)
    }

    async fn nanosleep(
        &mut self,
        duration: LinuxUserspaceArg<*const timespec>,
        _rem: LinuxUserspaceArg<Option<*const timespec>>,
    ) -> Result<isize, Errno> {
        let duration = duration.validate_ptr()?;
        if duration.tv_sec < 0 || !(0..=999999999).contains(&duration.tv_nsec) {
            return Err(Errno::EINVAL);
        }
        timer::sleep(&duration)?.await;
        Ok(0)
    }

    async fn clock_nanosleep(
        &mut self,
        clockid: c_int,
        flags: c_int,
        request: LinuxUserspaceArg<*const timespec>,
        _remain: LinuxUserspaceArg<Option<*mut timespec>>,
    ) -> Result<isize, Errno> {
        assert!(
            clockid == CLOCK_MONOTONIC as c_int || clockid == CLOCK_REALTIME as c_int,
            "clock_nanosleep: unsupported clockid {clockid}"
        );
        assert!(flags == 0, "clock_nanosleep: unsupported flags {flags}");
        let duration = request.validate_ptr()?;
        if duration.tv_sec < 0 || !(0..=999999999).contains(&duration.tv_nsec) {
            return Err(Errno::EINVAL);
        }
        timer::sleep(&duration)?.await;
        Ok(0)
    }

    async fn brk(&mut self, brk: c_ulong) -> Result<isize, headers::errno::Errno> {
        self.current_process.with_lock(|mut p| {
            Ok(p.brk(crate::memory::VirtAddr::new(brk.as_usize()))
                .as_usize() as isize)
        })
    }

    async fn mmap(
        &mut self,
        addr: usize,
        length: usize,
        prot: c_uint,
        flags: c_uint,
        fd: c_int,
        offset: isize,
    ) -> Result<isize, headers::errno::Errno> {
        assert_eq!(
            flags & !(MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED),
            0,
            "Only this flags are implemented so far."
        );
        assert_eq!(
            flags & (MAP_ANONYMOUS | MAP_PRIVATE),
            MAP_ANONYMOUS | MAP_PRIVATE,
            "File backed mappings and shared mappings are not supported yet."
        );
        assert_eq!(fd, -1, "fd must be -1 when working in MAP_ANONYMOUS");
        assert_eq!(
            offset, 0,
            "offset must be null when working with MAP_ANONYMOUS"
        );
        assert_eq!(
            length % PAGE_SIZE,
            0,
            "Length must be dividable through PAGE_SIZE"
        );
        if (flags & MAP_FIXED) > 0 && addr == 0 {
            return Err(Errno::EINVAL);
        }
        if length == 0 {
            return Err(Errno::EINVAL);
        }
        // Handle special PROT_NONE case and map it to the null pointer
        if prot == PROT_NONE {
            return self.current_process.with_lock(|mut p| {
                if p.get_page_table()
                    .is_mapped(VirtAddr::new(addr)..VirtAddr::new(addr + length))
                {
                    return Err(Errno::EEXIST);
                }
                p.get_page_table_mut().map_userspace(
                    VirtAddr::new(addr),
                    PhysAddr::new(0),
                    length / PAGE_SIZE,
                    XWRMode::ReadOnly,
                    "PROT_NONE".into(),
                );
                Ok(addr as isize)
            });
        }
        let permission = match prot {
            PROT_EXEC => XWRMode::ExecuteOnly,
            PROT_READ => XWRMode::ReadOnly,
            x if x == (PROT_READ | PROT_WRITE) => XWRMode::ReadWrite,
            _ => return Err(Errno::EINVAL),
        };
        self.current_process.with_lock(|mut p| {
            if (flags & MAP_FIXED) > 0 {
                if p.get_page_table()
                    .is_mapped(VirtAddr::new(addr)..VirtAddr::new(addr + length))
                {
                    return Err(Errno::EEXIST);
                }
                let ptr = p.mmap_pages_with_address(
                    Pages::new(length / PAGE_SIZE),
                    VirtAddr::new(addr),
                    permission,
                );
                return Ok(ptr as isize);
            }
            if addr == 0
                || p.get_page_table()
                    .is_mapped(VirtAddr::new(addr)..VirtAddr::new(addr + length))
            {
                return Ok(p.mmap_pages(Pages::new(length / PAGE_SIZE), permission) as isize);
            }
            Ok(p.mmap_pages_with_address(
                Pages::new(length / PAGE_SIZE),
                VirtAddr::new(addr),
                permission,
            ) as isize)
        })
    }

    async fn munmap(&mut self, addr: usize, length: usize) -> Result<isize, headers::errno::Errno> {
        if !addr.is_multiple_of(PAGE_SIZE) || length == 0 {
            return Err(Errno::EINVAL);
        }
        self.current_process
            .with_lock(|mut p| p.munmap_pages(VirtAddr::new(addr), length))?;
        Ok(0)
    }

    async fn prctl(&mut self) -> Result<isize, headers::errno::Errno> {
        // We dont support any of prctl right now
        Err(Errno::EINVAL)
    }

    async fn ioctl(
        &mut self,
        fd: c_int,
        op: c_uint,
        arg: usize,
    ) -> Result<isize, headers::errno::Errno> {
        let descriptor = self
            .current_process
            .with_lock(|p| p.fd_table().get(fd).map(|e| e.descriptor.clone()))
            .ok_or(Errno::EBADF)?;

        match descriptor {
            FileDescriptor::Stdout | FileDescriptor::Stderr if op == TIOCGWINSZ => {
                Err(Errno::ENOTTY)
            }
            FileDescriptor::Stdout if op == SENTIENT_LIST_PROGRAMS => {
                for (name, _) in PROGRAMS {
                    print!("{name} ");
                }
                println!();
                Ok(0)
            }
            FileDescriptor::Stdout if op == SENTIENT_PANIC => {
                panic!("Userspace triggered kernel panic");
            }
            FileDescriptor::UdpSocket(_) | FileDescriptor::UnboundUdpSocket if op == FIONBIO => {
                let arg_ptr = LinuxUserspaceArg::<*const c_int>::new(arg, self.get_process());
                let value = arg_ptr.validate_ptr()?;
                let flags = if value != 0 {
                    FdFlags::from_raw(headers::syscall_types::O_NONBLOCK as i32)
                } else {
                    FdFlags::default()
                };
                self.current_process
                    .with_lock(|mut p| p.fd_table_mut().set_flags(fd, flags))?;
                Ok(0)
            }
            _ => Err(Errno::EINVAL),
        }
    }

    async fn writev(
        &mut self,
        fd: c_int,
        iov: LinuxUserspaceArg<*const iovec>,
        iovcnt: c_int,
    ) -> Result<isize, headers::errno::Errno> {
        let descriptor = self
            .current_process
            .with_lock(|p| p.fd_table().get(fd).map(|e| e.descriptor.clone()))
            .ok_or(Errno::EBADF)?;

        let iov = iov.validate_slice(usize::try_from(iovcnt).map_err(|_| Errno::EINVAL)?)?;
        let mut data = Vec::new();

        for io in iov {
            let buf = LinuxUserspaceArg::<*const u8>::new(io.iov_base as usize, self.get_process());
            let mut buf = buf.validate_slice(io.iov_len.as_usize())?;
            data.append(&mut buf);
        }

        let len = data.len();
        descriptor.write(&data)?;

        Ok(len as isize)
    }

    async fn close(
        &mut self,
        fd: <c_int as crate::syscalls::macros::NeedsUserSpaceWrapper>::Wrapped,
    ) -> Result<isize, headers::errno::Errno> {
        self.current_process
            .with_lock(|mut p| p.fd_table_mut().close(fd))?;
        Ok(0)
    }

    async fn fcntl(
        &mut self,
        fd: c_int,
        cmd: c_int,
        arg: c_ulong,
    ) -> Result<isize, headers::errno::Errno> {
        match cmd.cast_unsigned() {
            F_GETFL => {
                let flags = self
                    .current_process
                    .with_lock(|p| p.fd_table().get_flags(fd))?;
                Ok(flags.as_raw() as isize)
            }
            F_SETFL => {
                let raw = i32::try_from(arg).map_err(|_| Errno::EINVAL)?;
                let flags = FdFlags::from_raw(raw);
                self.current_process
                    .with_lock(|mut p| p.fd_table_mut().set_flags(fd, flags))?;
                Ok(0)
            }
            _ => Err(Errno::EINVAL),
        }
    }

    async fn getppid(&mut self) -> Result<isize, headers::errno::Errno> {
        let parent_tid = self.current_thread.lock().parent_tid();
        Ok(parent_tid.as_isize())
    }

    async fn gettid(&mut self) -> Result<isize, headers::errno::Errno> {
        Ok(self.current_tid.as_isize())
    }

    async fn socket(
        &mut self,
        domain: c_int,
        typ: c_int,
        _protocol: c_int,
    ) -> Result<isize, Errno> {
        let masked_type = typ & !SOCK_CLOEXEC;
        assert!(
            domain == AF_INET && masked_type == SOCK_DGRAM,
            "socket: only AF_INET + SOCK_DGRAM supported (got domain={domain}, type={typ:#x})"
        );

        let fd = self
            .current_process
            .with_lock(|mut p| p.fd_table_mut().allocate(FileDescriptor::UnboundUdpSocket))?;
        Ok(fd as isize)
    }

    async fn bind(
        &mut self,
        fd: c_int,
        addr: LinuxUserspaceArg<*const u8>,
        addrlen: c_uint,
    ) -> Result<isize, Errno> {
        assert!(
            addrlen as usize >= core::mem::size_of::<sockaddr_in>(),
            "bind: addrlen too small ({addrlen})"
        );

        let descriptor = self
            .current_process
            .with_lock(|p| p.fd_table().get(fd).map(|e| e.descriptor.clone()))
            .ok_or(Errno::EBADF)?;

        assert!(
            matches!(descriptor, FileDescriptor::UnboundUdpSocket),
            "bind: fd {fd} is not an unbound UDP socket"
        );

        let sin_arg =
            LinuxUserspaceArg::<*const sockaddr_in>::new(addr.raw_arg(), self.get_process());
        let sin = sin_arg.validate_ptr()?;
        let port = Port::new(u16::from_be(sin.sin_port));

        let socket = net::open_sockets()
            .lock()
            .try_get_socket(port)
            .ok_or(Errno::EADDRINUSE)?;

        self.current_process.with_lock(|mut p| {
            p.fd_table_mut()
                .replace_descriptor(fd, FileDescriptor::UdpSocket(socket))
        })?;

        Ok(0)
    }

    async fn sendto(
        &mut self,
        fd: c_int,
        buf: LinuxUserspaceArg<*const u8>,
        len: usize,
        _flags: c_int,
        dest_addr: LinuxUserspaceArg<*const u8>,
        addrlen: c_uint,
    ) -> Result<isize, Errno> {
        assert!(
            addrlen as usize >= core::mem::size_of::<sockaddr_in>(),
            "sendto: addrlen too small ({addrlen})"
        );

        let socket = self
            .current_process
            .with_lock(|p| {
                p.fd_table().get(fd).and_then(|e| match &e.descriptor {
                    FileDescriptor::UdpSocket(s) => Some(s.clone()),
                    _ => None,
                })
            })
            .ok_or(Errno::EBADF)?;

        let data = buf.validate_slice(len)?;
        let sin_arg =
            LinuxUserspaceArg::<*const sockaddr_in>::new(dest_addr.raw_arg(), self.get_process());
        let sin = sin_arg.validate_ptr()?;

        let dest_ip = core::net::Ipv4Addr::from(u32::from_be(sin.sin_addr.s_addr));
        let dest_port = u16::from_be(sin.sin_port);

        let destination_mac =
            arp::cache_lookup(&dest_ip).expect("sendto: destination MAC must be in ARP cache");

        let source_port = socket.lock().get_port().as_u16();
        let packet =
            UdpHeader::create_udp_packet(dest_ip, dest_port, destination_mac, source_port, &data);
        net::send_packet(packet);

        Ok(len as isize)
    }

    async fn recvfrom(
        &mut self,
        fd: c_int,
        buf: LinuxUserspaceArg<*mut u8>,
        len: usize,
        _flags: c_int,
        src_addr: LinuxUserspaceArg<Option<*mut u8>>,
        addrlen: LinuxUserspaceArg<Option<*mut c_uint>>,
    ) -> Result<isize, Errno> {
        net::receive_and_process_packets();

        let socket = self
            .current_process
            .with_lock(|p| {
                p.fd_table().get(fd).and_then(|e| match &e.descriptor {
                    FileDescriptor::UdpSocket(s) => Some(s.clone()),
                    _ => None,
                })
            })
            .ok_or(Errno::EBADF)?;

        let mut tmp_buf = alloc::vec![0u8; len];
        let result = socket.lock().get_datagram(&mut tmp_buf);

        match result {
            // TODO: blocking recvfrom should wait for data instead of returning EAGAIN
            None => Err(Errno::EAGAIN),
            Some((bytes_read, from_ip, from_port)) => {
                buf.write_slice(&tmp_buf[..bytes_read])?;

                if src_addr.arg_nonzero() {
                    let sin = sockaddr_in {
                        sin_family: u16::try_from(AF_INET).expect("AF_INET fits in u16"),
                        sin_port: from_port.as_u16().to_be(),
                        sin_addr: headers::socket::in_addr {
                            s_addr: u32::from(from_ip).to_be(),
                        },
                        sin_zero: [0; 8],
                    };
                    let src_writer =
                        LinuxUserspaceArg::<*mut u8>::new(src_addr.raw_arg(), self.get_process());
                    src_writer.write_slice(sin.as_slice())?;
                    let addrlen_val = c_uint::try_from(core::mem::size_of::<sockaddr_in>())
                        .expect("sockaddr_in size fits in c_uint");
                    addrlen.write_if_not_none(addrlen_val)?;
                }

                Ok(bytes_read as isize)
            }
        }
    }

    async fn wait4(
        &mut self,
        pid: c_int,
        status: LinuxUserspaceArg<Option<*mut c_int>>,
        options: c_int,
        _rusage: usize,
    ) -> Result<isize, headers::errno::Errno> {
        assert!(
            pid > 0 || pid == -1,
            "wait4: unsupported pid value {pid} (no process groups yet)"
        );
        let wnohang = (options & headers::syscall_types::WNOHANG as c_int) != 0;
        assert!(
            options & !(headers::syscall_types::WNOHANG as c_int) == 0,
            "wait4: unsupported options {options:#x}"
        );

        let parent_main_tid = self.current_thread.lock().get_tid();
        let (child_tid, wait_status) = WaitChild::new(parent_main_tid, pid, wnohang).await?;

        status.write_if_not_none(wait_status)?;

        Ok(child_tid.as_isize())
    }

    async fn clone(
        &mut self,
        flags: c_ulong,
        stack: usize,
        _ptid: LinuxUserspaceArg<Option<*mut c_int>>,
        _tls: c_ulong,
        _ctid: LinuxUserspaceArg<Option<*mut c_int>>,
    ) -> Result<isize, Errno> {
        let expected = c_ulong::from(CLONE_VM | CLONE_VFORK | SIGCHLD);
        assert!(
            flags == expected,
            "clone: unsupported flags {flags:#x}, only CLONE_VM|CLONE_VFORK|SIGCHLD ({expected:#x}) supported"
        );

        let parent_regs = Cpu::read_trap_frame();
        let parent_pc = Cpu::read_sepc();

        let parent_process = self.current_process.clone();
        let (parent_main_tid, child_name) =
            parent_process.with_lock(|p| (p.main_tid(), Arc::new(String::from(p.get_name()))));

        let vfork_state = VforkState::new();

        let child_tid = get_next_tid();

        let child_page_table =
            crate::memory::page_tables::RootPageTableHolder::new_with_kernel_mapping(false);
        let child_process = Arc::new(crate::klibc::Spinlock::new(Process::new(
            child_name.clone(),
            child_page_table,
            Vec::new(),
            Brk::empty(),
            child_tid,
        )));
        child_process
            .lock()
            .set_vfork_parent(parent_process.clone());

        let mut child_regs = parent_regs;
        child_regs[Register::a0] = 0; // child gets 0 from clone
        if stack != 0 {
            child_regs[Register::sp] = stack;
        }

        let child_thread = Thread::new(
            child_tid,
            child_name,
            child_regs,
            VirtAddr::new(parent_pc + 4), // skip ecall
            false,
            child_process.clone(),
            parent_main_tid,
        );

        child_thread.lock().set_vfork_state(vfork_state.clone());

        child_process
            .lock()
            .add_thread(child_tid, Arc::downgrade(&child_thread));
        process_table::THE.lock().add_thread(child_thread);

        VforkWait::new(vfork_state).await;

        Ok(child_tid.as_isize())
    }

    async fn execve(&mut self, filename: usize, argv: usize, _envp: usize) -> Result<isize, Errno> {
        let process = self.get_process();
        let filename_bytes = process.with_lock(|p| {
            let ptr = UserspacePtr::new(filename as *const u8);
            p.read_userspace_slice(&ptr, 256)
        })?;
        let mut buf = ConsumableBuffer::new(&filename_bytes);
        let filename_str = buf.consume_str().ok_or(Errno::EFAULT)?;
        let name = filename_str.strip_prefix('/').unwrap_or(filename_str);

        // Read argv
        let mut args: Vec<&str> = Vec::new();
        let argv_ptrs = process.with_lock(|p| {
            let ptr = UserspacePtr::new(argv as *const usize);
            p.read_userspace_slice(&ptr, 32)
        })?;

        // Skip argv[0] (program name) since load_elf adds it automatically
        let mut arg_buffers: Vec<Vec<u8>> = Vec::new();
        let mut first = true;
        for &arg_ptr in &argv_ptrs {
            if arg_ptr == 0 {
                break;
            }
            if first {
                first = false;
                continue;
            }
            let arg_bytes = process.with_lock(|p| {
                let ptr = UserspacePtr::new(arg_ptr as *const u8);
                p.read_userspace_slice(&ptr, 256)
            })?;
            arg_buffers.push(arg_bytes);
        }
        for buf_ref in &arg_buffers {
            let mut cb = ConsumableBuffer::new(buf_ref);
            if let Some(s) = cb.consume_str() {
                args.push(s);
            }
        }

        let elf_data = PROGRAMS
            .iter()
            .find(|(prog_name, _)| *prog_name == name)
            .map(|(_, data)| *data)
            .ok_or(Errno::ENOENT)?;

        let elf = ElfFile::parse(elf_data).expect("Cannot parse ELF file");
        let loaded = loader::load_elf(&elf, name, &args).expect("ELF loading must succeed");

        let process_name = Arc::new(String::from(name));
        let new_process = Arc::new(crate::klibc::Spinlock::new(Process::new(
            process_name.clone(),
            loaded.page_tables,
            loaded.allocated_pages,
            loaded.brk,
            self.current_thread.lock().get_tid(),
        )));

        let current_thread = self.current_thread.clone();
        let old_process = current_thread.lock().process();
        let tid = current_thread.lock().get_tid();

        old_process.lock().remove_thread(tid);

        current_thread.with_lock(|mut t| {
            t.set_process(new_process.clone(), process_name);
            let mut regs = TrapFrame::zero();
            regs[Register::a0] = loaded.args_start.as_usize();
            regs[Register::sp] = loaded.args_start.as_usize();
            t.set_register_state(regs);
            t.set_program_counter(loaded.entry_address);
            t.set_registers_replaced(true);

            if let Some(vfork_state) = t.take_vfork_state() {
                vfork_state.lock().wake();
            }
        });

        new_process
            .lock()
            .add_thread(tid, Arc::downgrade(&current_thread));

        Ok(0)
    }
}

impl LinuxSyscallHandler {
    pub fn new() -> Self {
        let current_thread = Cpu::with_scheduler(|s| s.get_current_thread().clone());
        let (current_tid, current_process) =
            current_thread.with_lock(|t| (t.get_tid(), t.process()));
        Self {
            current_process,
            current_thread,
            current_tid,
        }
    }

    fn validate_poll_timeout(to: Option<timespec>) {
        if let Some(to) = to {
            assert_eq!(to.tv_sec, 0, "ppoll with timeout not yet implemented");
            assert_eq!(to.tv_nsec, 0, "ppoll with timeout not yet implemented");
        }
    }
}
