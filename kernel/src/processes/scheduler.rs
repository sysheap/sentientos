use super::process::{Pid, Process, ProcessState};
use crate::{
    autogenerated::userspace_programs::{INIT, PROGRAMS},
    cpu::{self},
    debug, info,
    interrupts::{read_trap_frame, set_sscratch_to_kernel_trap_frame, write_trap_frame},
    io::stdin_buf::STDIN_BUFFER,
    klibc::elf::ElfFile,
    memory::page_tables::{activate_page_table, KERNEL_PAGE_TABLES},
    processes::{process_table, timer},
    test::qemu_exit,
};
use alloc::sync::Arc;
use common::mutex::Mutex;

pub fn initialize() {
    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let process = Process::from_elf(&elf, "init");
    process_table::THE.lock().add_process(process);
    info!("Scheduler initialized and INIT process added to queue");
}

static CURRENT_PROCESS: Mutex<Option<Arc<Mutex<Process>>>> = Mutex::new(None);

pub unsafe fn disarm_current_process() {
    CURRENT_PROCESS.disarm();
}

pub fn get_current_process_expect() -> Arc<Mutex<Process>> {
    get_current_process()
        .expect("There must be a running current process")
        .clone()
}

pub fn get_current_process() -> Option<Arc<Mutex<Process>>> {
    CURRENT_PROCESS.lock().as_ref().map(|p| p.clone())
}

pub fn schedule() {
    debug!("Schedule next process");
    if prepare_next_process() {
        timer::set_timer(10);
        return;
    }
    activate_page_table(&KERNEL_PAGE_TABLES);
    timer::disable_timer();
    let addr = cpu::wfi_loop as *const () as usize;
    debug!("setting sepc={addr:#x}");
    cpu::write_sepc(addr);
    cpu::set_ret_to_kernel_mode(true);
    set_sscratch_to_kernel_trap_frame();
}

pub fn kill_current_process() {
    let current_process = CURRENT_PROCESS.lock().take();
    if let Some(current_process) = current_process {
        activate_page_table(&KERNEL_PAGE_TABLES);
        let pid = current_process.lock().get_pid();
        drop(current_process);
        process_table::THE.lock().kill(pid);
    }
    schedule();
}

pub fn let_current_process_wait_for(pid: Pid) -> bool {
    process_table::THE.with_lock(|pt| {
        if !pt.does_pid_exist(pid) {
            return false;
        }
        let current_process_lock = CURRENT_PROCESS.lock();
        let current_process = current_process_lock
            .as_ref()
            .expect("There should be a process.");

        let mut current_process = current_process.lock();
        current_process.set_state(ProcessState::Waiting);
        current_process.set_syscall_return_code(0);

        let wait_for = pt.get_process(pid).expect("This process must exist");
        wait_for.lock().add_notify_on_die(current_process.get_pid());

        true
    })
}

pub fn let_current_process_wait_for_input() {
    let current_process_lock = CURRENT_PROCESS.lock();
    let current_process = current_process_lock
        .as_ref()
        .expect("There should be a process.");

    let mut current_process = current_process.lock();
    STDIN_BUFFER
        .lock()
        .register_wakeup(current_process.get_pid());
    current_process.set_state(ProcessState::Waiting);
}

pub fn send_ctrl_c() {
    queue_current_process_back();

    process_table::THE.with_lock(|mut pt| {
        let highest_pid = pt.get_highest_pid_without_yash();

        if let Some(pid) = highest_pid {
            activate_page_table(&KERNEL_PAGE_TABLES);
            pt.kill(pid);
        }
    });

    schedule();
}

pub fn schedule_program(name: &str) -> Option<Pid> {
    for (prog_name, elf) in PROGRAMS {
        if name == *prog_name {
            let elf = ElfFile::parse(elf).expect("Cannot parse ELF file");
            let process = Process::from_elf(&elf, prog_name);
            let pid = process.get_pid();
            process_table::THE.lock().add_process(process);
            return Some(pid);
        }
    }
    None
}

fn queue_current_process_back() -> Option<Pid> {
    let current_process = CURRENT_PROCESS.lock().take();

    if let Some(current_process) = current_process {
        let mut current_process = current_process.lock();
        current_process.set_program_counter(cpu::read_sepc());
        current_process.set_in_kernel_mode(cpu::is_in_kernel_mode());
        current_process.set_register_state(&read_trap_frame());
        let pid = current_process.get_pid();
        debug!(
            "Unscheduling PID={} NAME={}",
            pid,
            current_process.get_name()
        );
        Some(pid)
    } else {
        None
    }
}

fn prepare_next_process() -> bool {
    let old_pid = queue_current_process_back().unwrap_or(0);

    let next_process = process_table::THE.with_lock(|pt| {
        if pt.is_empty() {
            info!("No more processes to schedule, shutting down system");
            qemu_exit::exit_success();
        }

        pt.next_runnable(old_pid)
    });

    let next_process = if let Some(process) = next_process {
        process
    } else {
        return false;
    };

    next_process.with_lock(|p| {
        let pc = p.get_program_counter();

        write_trap_frame(p.get_register_state());
        cpu::write_sepc(pc);
        cpu::set_ret_to_kernel_mode(p.get_in_kernel_mode());
        activate_page_table(p.get_page_table());

        debug!("Scheduling PID={} NAME={}", p.get_pid(), p.get_name());
    });

    *CURRENT_PROCESS.lock() = Some(next_process);

    true
}
