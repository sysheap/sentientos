use super::{
    process::{POWERSAVE_TID, ProcessRef},
    process_table::{self},
    thread::{ThreadRef, ThreadState},
};
use crate::{
    autogenerated::userspace_programs::PROGRAMS,
    cpu::Cpu,
    debug, info,
    klibc::elf::ElfFile,
    processes::{thread::Thread, timer},
    test::qemu_exit,
};
use alloc::sync::Arc;
use common::{errors::SchedulerError, pid::Tid, syscalls::trap_frame::TrapFrame, unwrap_or_return};
use core::mem::offset_of;

pub const TRAP_FRAME_OFFSET: usize = offset_of!(CpuScheduler, trap_frame);

pub struct CpuScheduler {
    trap_frame: TrapFrame,
    current_thread: ThreadRef,
    powersave_thread: ThreadRef,
}

impl CpuScheduler {
    pub fn new() -> Self {
        let powersave_thread = Thread::create_powersave_thread();

        Self {
            trap_frame: TrapFrame::zero(),
            current_thread: powersave_thread.clone(),
            powersave_thread,
        }
    }

    pub fn trap_frame(&self) -> &TrapFrame {
        &self.trap_frame
    }

    pub fn trap_frame_mut(&mut self) -> &mut TrapFrame {
        &mut self.trap_frame
    }

    pub fn get_current_thread(&self) -> &ThreadRef {
        &self.current_thread
    }

    pub fn get_current_process(&self) -> ProcessRef {
        self.current_thread.lock().process()
    }

    pub fn is_current_process_energy_saver(&self) -> bool {
        Arc::ptr_eq(&self.current_thread, &self.powersave_thread)
    }

    pub fn schedule(&mut self) {
        debug!("Schedule next process");
        self.check_wakeup_queue();
        self.prepare_next_process();
        if self.is_current_process_energy_saver() {
            timer::set_timer(50);
        } else {
            timer::set_timer(10);
        }
    }

    fn check_wakeup_queue(&mut self) {
        let wakeup_threads = timer::return_threads_to_wakeup();
        for thread in wakeup_threads.into_iter().filter_map(|w| w.upgrade()) {
            thread.with_lock(|mut t| {
                t.resume_on_syscall_linux();
            });
        }
    }

    pub fn kill_current_process(&mut self) {
        let tid = self.current_thread.lock().process().with_lock(|p| {
            // TODO: Kill other threads first
            assert_eq!(
                p.threads_len(),
                1,
                "We currently don't support to kill other threads"
            );

            assert!(Arc::ptr_eq(&self.current_thread, &p.main_thread()));

            p.main_tid()
        });

        self.queue_current_process_back();
        process_table::THE.lock().kill(tid);
        self.schedule();
    }

    pub fn let_current_thread_wait_for(&self, tid: Tid) -> bool {
        let wait_for_thread = unwrap_or_return!(process_table::THE.lock().get_thread(tid), false);

        self.current_thread.with_lock(|mut t| {
            t.set_state(ThreadState::Waiting);
            wait_for_thread.lock().add_notify_on_die(t.get_tid());
        });

        true
    }

    pub fn send_ctrl_c(&mut self) {
        self.queue_current_process_back();

        process_table::THE.with_lock(|mut pt| {
            let highest_pid = pt.get_highest_tid_without(&["sesh"]);

            if let Some(pid) = highest_pid {
                pt.kill(pid);
            }
        });
    }

    pub fn start_program(&mut self, name: &str, args: &[&str]) -> Result<Tid, SchedulerError> {
        for (prog_name, elf) in PROGRAMS {
            if name == *prog_name {
                let elf = ElfFile::parse(elf).expect("Cannot parse ELF file");
                let process = Thread::from_elf(&elf, prog_name, args)?;
                let tid = process.lock().get_tid();
                process_table::THE.lock().add_thread(process);
                return Ok(tid);
            }
        }
        Err(SchedulerError::InvalidProgramName)
    }

    pub fn powersave_thread(&self) -> ThreadRef {
        self.powersave_thread.clone()
    }

    fn queue_current_process_back(&mut self) {
        if self.current_thread.lock().get_tid() == POWERSAVE_TID {
            debug!("Current thread is already powersave thread - don't queuing back");
            return;
        }
        self.swap_current_with_powersave().with_lock(|mut t| {
            if t.get_state() == ThreadState::Running {
                t.set_state(ThreadState::Runnable);
            }

            t.set_program_counter(Cpu::read_sepc());
            t.set_register_state(&self.trap_frame);

            debug!("Saved thread {} back", *t);
        });
    }

    fn prepare_next_process(&mut self) {
        self.queue_current_process_back();

        process_table::THE.with_lock(|mut pt| {
            if pt.is_empty() {
                info!("No more processes to schedule, shutting down system");
                qemu_exit::exit_success();
            }

            debug!("Getting next runnable process");

            assert!(
                self.is_current_process_energy_saver(),
                "Current thread must be powersave thread to not have any dangling references"
            );

            // next_runnable already sets the state to ThreadState::Running
            let next_runnable = pt.next_runnable().unwrap_or(self.powersave_thread.clone());

            debug!("Next runnable is {}", *next_runnable.lock());

            self.current_thread = next_runnable;
        });

        self.set_cpu_reg_for_current_thread();
    }

    fn set_cpu_reg_for_current_thread(&mut self) {
        self.current_thread.with_lock(|mut t| {
            let pc = t.get_program_counter();

            t.finalize_syscall();
            self.trap_frame = *t.get_register_state();
            Cpu::write_sepc(pc);
            Cpu::set_ret_to_kernel_mode(t.get_in_kernel_mode());
        });
    }

    fn swap_current_with_powersave(&mut self) -> ThreadRef {
        core::mem::replace(&mut self.current_thread, self.powersave_thread.clone())
    }
}
