use common::unwrap_or_return;
use core::mem::offset_of;

use alloc::sync::Arc;
use common::syscalls::trap_frame::TrapFrame;

use crate::{
    autogenerated::userspace_programs::PROGRAMS,
    cpu::Cpu,
    debug, info,
    klibc::elf::ElfFile,
    processes::{process::Process, timer},
    test::qemu_exit,
};

use super::{
    process::{Pid, ProcessState, POWERSAVE_PID},
    process_table::{self, ProcessRef},
};

pub const TRAP_FRAME_OFFSET: usize = offset_of!(CpuScheduler, trap_frame);

pub struct CpuScheduler {
    trap_frame: TrapFrame,
    current_process: ProcessRef,
    powersave_process: ProcessRef,
}

impl CpuScheduler {
    pub fn new() -> Self {
        let powersave_process = Process::create_powersave_process();

        Self {
            trap_frame: TrapFrame::zero(),
            current_process: powersave_process.clone(),
            powersave_process,
        }
    }

    pub fn trap_frame(&self) -> &TrapFrame {
        &self.trap_frame
    }

    pub fn trap_frame_mut(&mut self) -> &mut TrapFrame {
        &mut self.trap_frame
    }

    pub fn get_current_process(&self) -> &ProcessRef {
        &self.current_process
    }

    pub fn is_current_process_energy_saver(&self) -> bool {
        Arc::ptr_eq(&self.current_process, &self.powersave_process)
    }

    pub fn schedule(&mut self) {
        debug!("Schedule next process");
        self.prepare_next_process();
        timer::set_timer(10);
    }

    pub fn kill_current_process(&mut self) {
        let pid = self.current_process.lock().get_pid();
        self.queue_current_process_back();
        process_table::THE.lock().kill(pid);
        self.schedule();
    }

    pub fn let_current_process_wait_for(&self, pid: Pid) -> bool {
        let wait_for_process =
            unwrap_or_return!(process_table::THE.lock().get_process(pid).cloned(), false);

        let mut current_process = self.current_process.lock();

        current_process.set_state(ProcessState::Waiting);

        wait_for_process
            .lock()
            .add_notify_on_die(current_process.get_pid());

        true
    }

    pub fn send_ctrl_c(&mut self) {
        self.queue_current_process_back();

        process_table::THE.with_lock(|mut pt| {
            let highest_pid = pt.get_highest_pid_without(&["yash"]);

            if let Some(pid) = highest_pid {
                pt.kill(pid);
            }
        });

        self.schedule();
    }

    pub fn start_program(&mut self, name: &str) -> Option<Pid> {
        for (prog_name, elf) in PROGRAMS {
            if name == *prog_name {
                let elf = ElfFile::parse(elf).expect("Cannot parse ELF file");
                let process = Process::from_elf(&elf, prog_name);
                let pid = process.get_pid();
                process_table::THE.lock().add_process(process);
                return Some(pid);
            }
        }
        None
    }

    fn queue_current_process_back(&mut self) -> Pid {
        if self.current_process.lock().get_pid() == POWERSAVE_PID {
            return POWERSAVE_PID;
        }
        self.swap_current_with_powersave().with_lock(|mut p| {
            match p.get_state() {
                ProcessState::Running => p.set_state(ProcessState::Runnable),
                ProcessState::Waiting => {}
                ProcessState::Runnable => panic!("Inavlid process state."),
            }

            p.set_program_counter(Cpu::read_sepc());
            p.set_in_kernel_mode(Cpu::is_in_kernel_mode());
            p.set_register_state(&self.trap_frame);
            let pid = p.get_pid();
            debug!("Unscheduling PID={} NAME={}", pid, p.get_name());
            pid
        })
    }

    fn prepare_next_process(&mut self) {
        let old_pid = self.queue_current_process_back();

        process_table::THE.with_lock(|pt| {
            if pt.is_empty() {
                info!("No more processes to schedule, shutting down system");
                qemu_exit::exit_success();
            }
            let next_runnable = pt
                .next_runnable(old_pid)
                .unwrap_or(self.powersave_process.clone());

            self.current_process = next_runnable;
            self.current_process.lock().set_state(ProcessState::Running);
        });

        self.set_cpu_reg_for_current_process();
    }

    fn set_cpu_reg_for_current_process(&mut self) {
        self.current_process.with_lock(|p| {
            let pc = p.get_program_counter();

            self.trap_frame = *p.get_register_state();
            Cpu::write_sepc(pc);
            Cpu::set_ret_to_kernel_mode(p.get_in_kernel_mode());

            debug!(
                "CPU set to PID={} NAME={} pc={pc:#x}",
                p.get_pid(),
                p.get_name()
            );
        });
    }

    fn swap_current_with_powersave(&mut self) -> ProcessRef {
        core::mem::replace(&mut self.current_process, self.powersave_process.clone())
    }
}
