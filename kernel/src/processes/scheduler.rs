use common::{errors::SchedulerError, pid::Pid, unwrap_or_return};
use core::mem::offset_of;

use alloc::sync::Arc;
use common::syscalls::trap_frame::TrapFrame;

use crate::{
    autogenerated::userspace_programs::PROGRAMS,
    cpu::Cpu,
    debug, info,
    klibc::elf::ElfFile,
    processes::{process::Process, timer},
    test::qemu_exit,
};

use super::{
    process::{ProcessRef, POWERSAVE_TID},
    process_table::{self},
    thread::{ThreadRef, ThreadState},
};

pub const TRAP_FRAME_OFFSET: usize = offset_of!(CpuScheduler, trap_frame);

pub struct CpuScheduler {
    trap_frame: TrapFrame,
    current_thread: ThreadRef,
    powersave_thread: ThreadRef,
    // This keeps the powersave process alive
    #[allow(dead_code)]
    powersave_process: ProcessRef,
}

impl CpuScheduler {
    pub fn new() -> Self {
        let powersave_process = Process::create_powersave_process();
        let powersave_thread = powersave_process.with_lock(|p| p.main_thread().clone());

        Self {
            trap_frame: TrapFrame::zero(),
            current_thread: powersave_thread.clone(),
            powersave_thread,
            powersave_process,
        }
    }

    pub fn trap_frame(&self) -> &TrapFrame {
        &self.trap_frame
    }

    pub fn trap_frame_mut(&mut self) -> &mut TrapFrame {
        &mut self.trap_frame
    }

    pub fn get_current_thread(&self) -> &ThreadRef {
        &self.current_thread
    }

    pub fn get_current_process(&self) -> ProcessRef {
        self.current_thread.lock().process()
    }

    pub fn is_current_process_energy_saver(&self) -> bool {
        Arc::ptr_eq(&self.current_thread, &self.powersave_thread)
    }

    pub fn schedule(&mut self) {
        debug!("Schedule next process");
        self.prepare_next_process();
        timer::set_timer(10);
    }

    pub fn kill_current_process(&mut self) {
        let pid = self.current_thread.lock().process().with_lock(|p| {
            // TODO: Kill other threads first
            assert_eq!(
                p.threads_len(),
                1,
                "We currently don't support to kill other threads"
            );

            assert!(Arc::ptr_eq(&self.current_thread, &p.main_thread()));

            p.get_pid()
        });

        self.queue_current_process_back();
        process_table::THE.lock().kill(pid);
        self.schedule();
    }

    pub fn let_current_thread_wait_for(&self, pid: Pid) -> bool {
        let wait_for_process =
            unwrap_or_return!(process_table::THE.lock().get_process(pid).cloned(), false);

        self.current_thread.with_lock(|mut t| {
            t.set_state(ThreadState::Waiting);
            wait_for_process.lock().add_notify_on_die(t.get_tid());
        });

        true
    }

    pub fn send_ctrl_c(&mut self) {
        self.queue_current_process_back();

        process_table::THE.with_lock(|mut pt| {
            let highest_pid = pt.get_highest_pid_without(&["sesh"]);

            if let Some(pid) = highest_pid {
                pt.kill(pid);
            }
        });

        self.schedule();
    }

    pub fn start_program(&mut self, name: &str, args: &[&str]) -> Result<Pid, SchedulerError> {
        for (prog_name, elf) in PROGRAMS {
            if name == *prog_name {
                let elf = ElfFile::parse(elf).expect("Cannot parse ELF file");
                let process = Process::from_elf(&elf, prog_name, args)?;
                let pid = process.lock().get_pid();
                process_table::THE.lock().add_process(process);
                return Ok(pid);
            }
        }
        Err(SchedulerError::InvalidProgramName)
    }

    pub fn powersave_process(&self) -> ProcessRef {
        self.powersave_process.clone()
    }

    pub fn powersave_thread(&self) -> ThreadRef {
        self.powersave_thread.clone()
    }

    fn queue_current_process_back(&mut self) {
        if self.current_thread.lock().get_tid() == POWERSAVE_TID {
            debug!("Current thread is already powersave thread - don't queuing back");
            return;
        }
        self.swap_current_with_powersave().with_lock(|mut t| {
            match t.get_state() {
                ThreadState::Running => t.set_state(ThreadState::Runnable),
                ThreadState::Waiting => {}
                ThreadState::Runnable => panic!("Inavlid process state."),
            }

            t.set_program_counter(Cpu::read_sepc());
            t.set_in_kernel_mode(Cpu::is_in_kernel_mode());
            t.set_register_state(&self.trap_frame);

            debug!("Saved thread {} back", *t);
        });
    }

    fn prepare_next_process(&mut self) {
        self.queue_current_process_back();

        process_table::THE.with_lock(|mut pt| {
            if pt.is_empty() {
                info!("No more processes to schedule, shutting down system");
                qemu_exit::exit_success();
            }

            debug!("Getting next runnable process");

            // next_runnable already sets the state to ThreadState::Running
            let next_runnable = pt.next_runnable().unwrap_or(self.powersave_thread.clone());

            debug!("Next runnable is {}", *next_runnable.lock());

            self.current_thread = next_runnable;
        });

        self.set_cpu_reg_for_current_thread();
    }

    fn set_cpu_reg_for_current_thread(&mut self) {
        self.current_thread.with_lock(|t| {
            let pc = t.get_program_counter();

            self.trap_frame = *t.get_register_state();
            Cpu::write_sepc(pc);
            Cpu::set_ret_to_kernel_mode(t.get_in_kernel_mode());
        });
    }

    fn swap_current_with_powersave(&mut self) -> ThreadRef {
        core::mem::replace(&mut self.current_thread, self.powersave_thread.clone())
    }
}
