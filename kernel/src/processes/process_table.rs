use alloc::{collections::BTreeMap, vec::Vec};
use common::pid::Tid;
use core::task::Waker;

use crate::{
    autogenerated::userspace_programs::INIT,
    cpu::Cpu,
    debug, info,
    klibc::{Spinlock, elf::ElfFile, runtime_initialized::RuntimeInitializedData},
    processes::{process::POWERSAVE_TID, thread::Thread},
};

use super::thread::{ThreadRef, ThreadState};

pub static THE: RuntimeInitializedData<Spinlock<ProcessTable>> = RuntimeInitializedData::new();

pub fn init() {
    let mut process_table = ProcessTable::new();

    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let thread = Thread::from_elf(&elf, "init", &[], Tid(0)).expect("init must succeed");
    process_table.add_thread(thread);

    THE.initialize(Spinlock::new(process_table));
}

pub struct ProcessTable {
    threads: BTreeMap<Tid, ThreadRef>,
    wait_wakers: Vec<Waker>,
}

impl ProcessTable {
    pub fn new() -> Self {
        Self {
            threads: BTreeMap::new(),
            wait_wakers: Vec::new(),
        }
    }

    pub fn add_thread(&mut self, thread: ThreadRef) {
        let tid = thread.lock().get_tid();
        assert!(
            self.threads.insert(tid, thread).is_none(),
            "Duplicate TID {tid} in process table"
        );
    }

    pub fn is_empty(&self) -> bool {
        self.threads
            .values()
            .all(|t| t.with_lock(|t| matches!(t.get_state(), ThreadState::Zombie(_))))
    }

    pub fn get_highest_tid_without(&self, process_names: &[&str]) -> Option<Tid> {
        self.threads
            .iter()
            .filter(|(_, t)| {
                let t = t.lock();
                !matches!(t.get_state(), ThreadState::Zombie(_))
                    && !process_names.iter().any(|n| t.get_name() == *n)
                    && t.get_tid() != POWERSAVE_TID
            })
            .max_by_key(|(pid, _)| *pid)
            .map(|(pid, _)| *pid)
    }

    pub fn dump(&self) {
        for process in self.threads.values() {
            if process
                .try_with_lock(|p| {
                    info!("{}", *p);
                })
                .is_none()
            {
                info!("Cannot dump process because it is locked.");
            }
        }
    }

    pub fn take_zombie(&mut self, parent_tid: Tid, pid: i32) -> Option<(Tid, i32)> {
        let is_zombie_of = |t: &ThreadRef| {
            t.with_lock(|t| {
                matches!(t.get_state(), ThreadState::Zombie(_))
                    && t.process().lock().parent_tid() == parent_tid
            })
        };

        let tid = if pid > 0 {
            let tid = Tid(u64::try_from(pid).expect("pid is positive"));
            if !is_zombie_of(self.threads.get(&tid)?) {
                return None;
            }
            tid
        } else {
            // pid == -1: any zombie child of parent
            *self
                .threads
                .iter()
                .find(|(_, t)| is_zombie_of(t))
                .map(|(tid, _)| tid)?
        };

        let thread = self.threads.remove(&tid).expect("tid was just found");
        let exit_code = thread.with_lock(|t| match t.get_state() {
            ThreadState::Zombie(code) => code,
            _ => unreachable!(),
        });
        Some((tid, i32::from(exit_code) << 8))
    }

    pub fn has_any_child_of(&self, parent_tid: Tid) -> bool {
        self.threads.values().any(|t| {
            t.with_lock(|t| {
                let process = t.process();
                process.lock().parent_tid() == parent_tid
            })
        })
    }

    pub fn register_wait_waker(&mut self, waker: Waker) {
        self.wait_wakers.push(waker);
    }

    fn wake_wait_wakers(&mut self) {
        for waker in self.wait_wakers.drain(..) {
            waker.wake();
        }
    }

    pub fn kill(&mut self, tid: Tid, exit_status: i32) {
        assert!(
            tid != POWERSAVE_TID,
            "We are not allowed to kill the never process"
        );
        debug!("Killing tid={tid}");
        let exit_code = u8::try_from(exit_status & 0xff).expect("masked to 8 bits");
        if let Some(thread) = self.threads.get(&tid).cloned() {
            let main_tid = thread.with_lock(|mut t| {
                t.set_state(ThreadState::Zombie(exit_code));
                Cpu::current().ipi_to_all_but_me();

                if let Some(clear_child_tid) = t.get_clear_child_tid() {
                    let process = t.process();
                    let _ = clear_child_tid.write_with_process_lock(&process.lock(), 0);
                }

                let process = t.process();
                process.lock().main_tid()
            });

            self.wake_wait_wakers();

            // Reparent orphans to init (Tid(1))
            let init_tid = Tid(1);
            for child_thread in self.threads.values() {
                child_thread.with_lock(|t| {
                    let process = t.process();
                    let mut process = process.lock();
                    if process.parent_tid() == main_tid {
                        process.set_parent_tid(init_tid);
                    }
                });
            }
        }
    }

    pub fn next_runnable(&mut self) -> Option<ThreadRef> {
        debug!(
            "Checking {} thread entries in weak queue",
            self.threads.len()
        );
        for thread in self.threads.values() {
            let runnable = thread.with_lock(|mut t| {
                debug!("Checking {}", *t);
                if t.get_state() != ThreadState::Runnable {
                    return false;
                }
                t.set_state(ThreadState::Running {
                    cpu_id: Cpu::cpu_id(),
                });
                true
            });
            if runnable {
                return Some(thread.clone());
            }
        }
        None
    }
}
