use alloc::{collections::BTreeMap, vec::Vec};
use common::pid::Tid;
use core::task::Waker;

use crate::{
    autogenerated::userspace_programs::INIT,
    cpu::Cpu,
    debug, info,
    klibc::{Spinlock, elf::ElfFile, runtime_initialized::RuntimeInitializedData},
    processes::{process::POWERSAVE_TID, thread::Thread},
};

use super::thread::{ThreadRef, ThreadState};

pub struct ZombieEntry {
    pub parent_tid: Tid,
    pub exit_status: i32,
}

pub static THE: RuntimeInitializedData<Spinlock<ProcessTable>> = RuntimeInitializedData::new();

pub fn init() {
    let mut process_table = ProcessTable::new();

    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let thread = Thread::from_elf(&elf, "init", &[], Tid(0)).expect("init must succeed");
    process_table.add_thread(thread);

    THE.initialize(Spinlock::new(process_table));
}

pub struct ProcessTable {
    threads: BTreeMap<Tid, ThreadRef>,
    zombies: BTreeMap<Tid, ZombieEntry>,
    wait_wakers: Vec<Waker>,
}

impl ProcessTable {
    pub fn new() -> Self {
        Self {
            threads: BTreeMap::new(),
            zombies: BTreeMap::new(),
            wait_wakers: Vec::new(),
        }
    }

    pub fn add_thread(&mut self, thread: ThreadRef) {
        let tid = thread.lock().get_tid();
        assert!(
            self.threads.insert(tid, thread).is_none(),
            "Duplicate TID {tid} in process table"
        );
    }

    pub fn is_empty(&self) -> bool {
        self.threads.is_empty()
    }

    pub fn get_highest_tid_without(&self, process_names: &[&str]) -> Option<Tid> {
        self.threads
            .iter()
            .max_by_key(|(pid, _)| *pid)
            .filter(|(_, p)| {
                let p = p.lock();
                !process_names.iter().any(|n| p.get_name() == *n) && p.get_tid() != POWERSAVE_TID
            })
            .map(|(pid, _)| *pid)
    }

    pub fn dump(&self) {
        for process in self.threads.values() {
            if process
                .try_with_lock(|p| {
                    info!("{}", *p);
                })
                .is_none()
            {
                info!("Cannot dump process because it is locked.");
            }
        }
    }

    pub fn take_zombie(&mut self, parent_tid: Tid, pid: i32) -> Option<(Tid, i32)> {
        if pid > 0 {
            let tid = Tid(u64::try_from(pid).expect("pid is positive"));
            let entry = self.zombies.get(&tid)?;
            if entry.parent_tid != parent_tid {
                return None;
            }
            let status = entry.exit_status;
            self.zombies.remove(&tid);
            Some((tid, status))
        } else {
            // pid == -1: any child of parent
            let tid = self
                .zombies
                .iter()
                .find(|(_, e)| e.parent_tid == parent_tid)
                .map(|(tid, _)| *tid)?;
            let entry = self.zombies.remove(&tid).expect("tid was just found");
            Some((tid, entry.exit_status))
        }
    }

    pub fn has_any_child_of(&self, parent_tid: Tid) -> bool {
        self.threads.values().any(|t| {
            t.with_lock(|t| {
                let process = t.process();
                let process = process.lock();
                process.parent_tid() == parent_tid
            })
        }) || self.zombies.values().any(|e| e.parent_tid == parent_tid)
    }

    pub fn register_wait_waker(&mut self, waker: Waker) {
        self.wait_wakers.push(waker);
    }

    fn wake_wait_wakers(&mut self) {
        for waker in self.wait_wakers.drain(..) {
            waker.wake();
        }
    }

    pub fn kill(&mut self, tid: Tid) {
        assert!(
            tid != POWERSAVE_TID,
            "We are not allowed to kill the never process"
        );
        debug!("Removing tid={tid} from process table");
        if let Some(thread) = self.threads.remove(&tid) {
            let (main_tid, parent_tid, exit_status) = thread.with_lock(|mut t| {
                t.set_state(ThreadState::Waiting);
                Cpu::current().ipi_to_all_but_me();

                if let Some(clear_child_tid) = t.get_clear_child_tid() {
                    let process = t.process();
                    let _ = clear_child_tid.write_with_process_lock(&process.lock(), 0);
                }

                let process = t.process();
                let process = process.lock();
                (
                    process.main_tid(),
                    process.parent_tid(),
                    process.exit_status(),
                )
            });

            self.zombies.insert(
                main_tid,
                ZombieEntry {
                    parent_tid,
                    exit_status: (exit_status & 0xff) << 8,
                },
            );
            self.wake_wait_wakers();

            // Reparent orphans to init (Tid(1))
            let init_tid = Tid(1);
            for child_thread in self.threads.values() {
                child_thread.with_lock(|t| {
                    let process = t.process();
                    let mut process = process.lock();
                    if process.parent_tid() == main_tid {
                        process.set_parent_tid(init_tid);
                    }
                });
            }
            for zombie in self.zombies.values_mut() {
                if zombie.parent_tid == main_tid {
                    zombie.parent_tid = init_tid;
                }
            }
        }
    }

    pub fn next_runnable(&mut self) -> Option<ThreadRef> {
        debug!(
            "Checking {} thread entries in weak queue",
            self.threads.len()
        );
        for thread in self.threads.values() {
            let runnable = thread.with_lock(|mut t| {
                debug!("Checking {}", *t);
                if t.get_state() != ThreadState::Runnable {
                    return false;
                }
                t.set_state(ThreadState::Running {
                    cpu_id: Cpu::cpu_id(),
                });
                true
            });
            if runnable {
                return Some(thread.clone());
            }
        }
        None
    }
}
