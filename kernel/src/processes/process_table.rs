use alloc::collections::BTreeMap;
use common::{mutex::Mutex, pid::Tid, runtime_initialized::RuntimeInitializedData};

use crate::{
    autogenerated::userspace_programs::INIT,
    debug, info,
    klibc::elf::ElfFile,
    processes::{process::POWERSAVE_TID, thread::Thread},
};

use super::thread::{ThreadRef, ThreadState};

pub static THE: RuntimeInitializedData<Mutex<ProcessTable>> = RuntimeInitializedData::new();

pub fn init() {
    let mut process_table = ProcessTable::new();

    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let thread = Thread::from_elf(&elf, "init", &[]).expect("init must succeed");
    process_table.add_thread(thread);

    THE.initialize(Mutex::new(process_table));
}

pub struct ProcessTable {
    threads: BTreeMap<Tid, ThreadRef>,
}

impl ProcessTable {
    pub fn new() -> Self {
        Self {
            threads: BTreeMap::new(),
        }
    }

    pub fn add_thread(&mut self, thread: ThreadRef) {
        let tid = thread.lock().get_tid();
        self.threads.insert(tid, thread);
    }

    pub fn is_empty(&self) -> bool {
        self.threads.is_empty()
    }

    pub fn get_highest_tid_without(&self, process_names: &[&str]) -> Option<Tid> {
        self.threads
            .iter()
            .max_by_key(|(pid, _)| *pid)
            .filter(|(_, p)| {
                let p = p.lock();
                !process_names.iter().any(|n| p.get_name() == *n) && p.get_tid() != POWERSAVE_TID
            })
            .map(|(pid, _)| *pid)
    }

    pub fn get_thread(&self, tid: Tid) -> Option<ThreadRef> {
        self.threads.get(&tid).cloned()
    }

    pub fn dump(&self) {
        for process in self.threads.values() {
            if process
                .try_with_lock(|p| {
                    info!("{}", *p);
                })
                .is_none()
            {
                info!("Cannot dump process because it is locked.");
            }
        }
    }

    pub fn kill(&mut self, tid: Tid) {
        assert!(
            tid != POWERSAVE_TID,
            "We are not allowed to kill the never process"
        );
        debug!("Removing tid={tid} from process table");
        if let Some(thread) = self.threads.remove(&tid) {
            thread.with_lock(|t| {
                for tid in t.get_notifies_on_die() {
                    self.wake_process_up(*tid);
                }
                if let Some(clear_child_tid) = t.get_clear_child_tid() {
                    let process = t.process();
                    // We don't care if the address is not mapped anymore
                    // Since this operation should only wake up other threads
                    let _ = clear_child_tid.write_with_process_lock(&process.lock(), 0);
                }
            });
        }
    }

    pub fn next_runnable(&mut self) -> Option<ThreadRef> {
        debug!(
            "Checking {} thread entries in weak queue",
            self.threads.len()
        );
        for thread in self.threads.values() {
            let runnable = thread.with_lock(|mut t| {
                debug!("Checking {}", *t);
                if t.get_state() != ThreadState::Runnable {
                    return false;
                }
                t.set_state(ThreadState::Running);
                true
            });
            if runnable {
                return Some(thread.clone());
            }
        }
        None
    }

    pub fn wake_process_up(&self, tid: Tid) {
        debug!("Waking thread up with tid={tid}");
        let thread = self.get_thread(tid).expect("Process must exist");
        thread.with_lock(|mut t| {
            assert_eq!(
                t.get_state(),
                ThreadState::Waiting,
                "Process must be in waiting state to be woken up"
            );
            t.set_state(ThreadState::Runnable);
        });
    }
}
