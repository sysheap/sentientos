use alloc::{collections::BTreeMap, sync::Arc};
use common::{
    mutex::Mutex,
    pid::{Pid, Tid},
    runtime_initialized::RuntimeInitializedData,
    weak_queue::WeakQueue,
};

use crate::{autogenerated::userspace_programs::INIT, debug, info, klibc::elf::ElfFile};

use super::{
    process::{POWERSAVE_PID, Process, ProcessRef},
    thread::{Thread, ThreadRef, ThreadState},
};

pub static THE: RuntimeInitializedData<Mutex<ProcessTable>> = RuntimeInitializedData::new();

pub fn init() {
    let mut process_table = ProcessTable::new();

    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let process = Process::from_elf(&elf, "init", &[]).expect("init must succeed");
    process_table.add_process(process);

    THE.initialize(Mutex::new(process_table));
}

pub struct ProcessTable {
    processes: BTreeMap<Pid, ProcessRef>,
    threads: WeakQueue<Mutex<Thread>>,
}

impl ProcessTable {
    pub fn new() -> Self {
        Self {
            processes: BTreeMap::new(),
            threads: WeakQueue::new(),
        }
    }

    pub fn add_process(&mut self, process: ProcessRef) {
        let pid = process.with_lock(|p| {
            for thread in p.threads() {
                self.threads.add(Arc::downgrade(thread));
            }

            p.get_pid()
        });
        self.processes.insert(pid, process);
    }

    pub fn is_empty(&self) -> bool {
        self.processes.is_empty()
    }

    pub fn get_highest_pid_without(&self, process_names: &[&str]) -> Option<Pid> {
        self.processes
            .iter()
            .max_by_key(|(pid, _)| *pid)
            .filter(|(_, p)| {
                let p = p.lock();
                !process_names.iter().any(|n| p.get_name() == *n) && p.get_pid() != POWERSAVE_PID
            })
            .map(|(pid, _)| *pid)
    }

    pub fn get_thread(&self, tid: Tid) -> Option<ThreadRef> {
        self.threads
            .readonly_iter()
            .find(|t| t.lock().get_tid() == tid)
    }

    pub fn dump(&self) {
        for process in self.processes.values() {
            info!("{}", *process.lock());
        }
    }

    pub fn kill(&mut self, pid: Pid) {
        assert!(
            pid != POWERSAVE_PID,
            "We are not allowed to kill the never process"
        );
        debug!("Removing pid={pid} from process table");
        if let Some(process) = self.processes.remove(&pid) {
            for pid in process.lock().get_notifies_on_die() {
                self.wake_process_up(*pid);
            }
        }
    }

    pub fn next_runnable(&mut self) -> Option<ThreadRef> {
        debug!(
            "Checking {} thread entries in weak queue",
            self.threads.len()
        );
        for thread in self.threads.iter() {
            debug!("Check if thread={thread:?} is runnable");
            let runnable = thread.with_lock(|mut t| {
                debug!("Checking {}", *t);
                if t.get_state() != ThreadState::Runnable {
                    return false;
                }
                t.set_state(ThreadState::Running);
                true
            });
            if runnable {
                return Some(thread);
            }
        }
        None
    }

    pub fn get_process(&self, pid: Pid) -> Option<&ProcessRef> {
        self.processes.get(&pid)
    }

    pub fn wake_process_up(&self, tid: Tid) {
        debug!("Waking thread up with tid={tid}");
        let thread = self.get_thread(tid).expect("Process must exist");
        thread.with_lock(|mut t| {
            assert_eq!(
                t.get_state(),
                ThreadState::Waiting,
                "Process must be in waiting state to be woken up"
            );
            t.set_state(ThreadState::Runnable);
        });
    }
}
