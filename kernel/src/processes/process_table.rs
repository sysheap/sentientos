use alloc::{collections::BTreeMap, vec::Vec};
use common::pid::Tid;

use crate::{
    autogenerated::userspace_programs::INIT,
    cpu::Cpu,
    debug, info,
    klibc::{Spinlock, elf::ElfFile, runtime_initialized::RuntimeInitializedData},
    processes::{process::POWERSAVE_TID, thread::Thread},
};

use super::thread::{ThreadRef, ThreadState};

pub static THE: RuntimeInitializedData<Spinlock<ProcessTable>> = RuntimeInitializedData::new();

pub fn init() {
    let mut process_table = ProcessTable::new();

    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let thread = Thread::from_elf(&elf, "init", &[], Tid(0)).expect("init must succeed");
    process_table.add_thread(thread);

    THE.initialize(Spinlock::new(process_table));
}

pub struct ProcessTable {
    threads: BTreeMap<Tid, ThreadRef>,
    exited_children: BTreeMap<Tid, Vec<Tid>>,
    waiting_for_any_child: BTreeMap<Tid, Tid>,
}

impl ProcessTable {
    pub fn new() -> Self {
        Self {
            threads: BTreeMap::new(),
            exited_children: BTreeMap::new(),
            waiting_for_any_child: BTreeMap::new(),
        }
    }

    pub fn add_thread(&mut self, thread: ThreadRef) {
        let tid = thread.lock().get_tid();
        assert!(
            self.threads.insert(tid, thread).is_none(),
            "Duplicate TID {tid} in process table"
        );
    }

    pub fn is_empty(&self) -> bool {
        self.threads.is_empty()
    }

    pub fn get_highest_tid_without(&self, process_names: &[&str]) -> Option<Tid> {
        self.threads
            .iter()
            .max_by_key(|(pid, _)| *pid)
            .filter(|(_, p)| {
                let p = p.lock();
                !process_names.iter().any(|n| p.get_name() == *n) && p.get_tid() != POWERSAVE_TID
            })
            .map(|(pid, _)| *pid)
    }

    pub fn get_thread(&self, tid: Tid) -> Option<ThreadRef> {
        self.threads.get(&tid).cloned()
    }

    pub fn dump(&self) {
        for process in self.threads.values() {
            if process
                .try_with_lock(|p| {
                    info!("{}", *p);
                })
                .is_none()
            {
                info!("Cannot dump process because it is locked.");
            }
        }
    }

    pub fn kill(&mut self, tid: Tid) {
        assert!(
            tid != POWERSAVE_TID,
            "We are not allowed to kill the never process"
        );
        debug!("Removing tid={tid} from process table");
        if let Some(thread) = self.threads.remove(&tid) {
            let (parent_tid, main_tid) = thread.with_lock(|mut t| {
                t.set_state(ThreadState::Waiting);
                Cpu::current().ipi_to_all_but_me();

                for tid in t.get_notifies_on_die() {
                    self.wake_process_up(*tid);
                }
                if let Some(clear_child_tid) = t.get_clear_child_tid() {
                    let process = t.process();
                    let _ = clear_child_tid.write_with_process_lock(&process.lock(), 0);
                }

                let process = t.process();
                let process = process.lock();
                (process.parent_tid(), process.main_tid())
            });

            self.record_exited_child(parent_tid, main_tid);

            if let Some(waiter_tid) = self.waiting_for_any_child.remove(&parent_tid) {
                self.wake_process_up(waiter_tid);
            }

            // Reparent orphans to init (Tid(1))
            let init_tid = Tid(1);
            for child_thread in self.threads.values() {
                child_thread.with_lock(|t| {
                    let process = t.process();
                    let mut process = process.lock();
                    if process.parent_tid() == main_tid {
                        process.set_parent_tid(init_tid);
                    }
                });
            }

            // Move exited_children entries from dying process to init
            if let Some(orphan_exits) = self.exited_children.remove(&main_tid) {
                self.exited_children
                    .entry(init_tid)
                    .or_default()
                    .extend(orphan_exits);
            }
        }
    }

    pub fn record_exited_child(&mut self, parent_tid: Tid, child_tid: Tid) {
        self.exited_children
            .entry(parent_tid)
            .or_default()
            .push(child_tid);
    }

    pub fn take_one_exited_child(&mut self, parent_tid: Tid) -> Option<Tid> {
        let children = self.exited_children.get_mut(&parent_tid)?;
        let child = children.pop();
        if children.is_empty() {
            self.exited_children.remove(&parent_tid);
        }
        child
    }

    pub fn next_runnable(&mut self) -> Option<ThreadRef> {
        debug!(
            "Checking {} thread entries in weak queue",
            self.threads.len()
        );
        for thread in self.threads.values() {
            let runnable = thread.with_lock(|mut t| {
                debug!("Checking {}", *t);
                if t.get_state() != ThreadState::Runnable {
                    return false;
                }
                t.set_state(ThreadState::Running {
                    cpu_id: Cpu::cpu_id(),
                });
                true
            });
            if runnable {
                return Some(thread.clone());
            }
        }
        None
    }

    pub fn has_live_children(&self, parent_main_tid: Tid) -> bool {
        self.threads
            .values()
            .any(|thread| thread.with_lock(|t| t.process().lock().parent_tid() == parent_main_tid))
    }

    pub fn register_waiting_for_any_child(&mut self, parent_main_tid: Tid, waiter_tid: Tid) {
        let prev = self
            .waiting_for_any_child
            .insert(parent_main_tid, waiter_tid);
        assert!(
            prev.is_none(),
            "Already waiting for any child of {parent_main_tid}"
        );
    }

    pub fn wake_process_up(&self, tid: Tid) {
        debug!("Waking thread up with tid={tid}");
        let thread = self.get_thread(tid).expect("Process must exist");
        thread.with_lock(|mut t| {
            t.wake_up();
        });
    }
}
