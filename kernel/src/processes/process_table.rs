use alloc::{
    collections::{BTreeMap, VecDeque},
    vec::Vec,
};
use common::pid::Tid;
use core::{
    sync::atomic::{AtomicUsize, Ordering},
    task::Waker,
};

use crate::{
    autogenerated::userspace_programs::INIT,
    cpu::Cpu,
    debug, info,
    klibc::{Spinlock, elf::ElfFile, runtime_initialized::RuntimeInitializedData},
    processes::{process::POWERSAVE_TID, thread::Thread},
};

use super::thread::{ThreadRef, ThreadState};

pub static RUN_QUEUE: Spinlock<VecDeque<ThreadRef>> = Spinlock::new(VecDeque::new());
static LIVE_THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);

pub fn is_empty() -> bool {
    LIVE_THREAD_COUNT.load(Ordering::Relaxed) == 0
}

pub static THE: RuntimeInitializedData<Spinlock<ProcessTable>> = RuntimeInitializedData::new();

pub fn init() {
    let mut process_table = ProcessTable::new();

    let elf = ElfFile::parse(INIT).expect("Cannot parse ELF file");
    let thread = Thread::from_elf(&elf, "init", &[], Tid::new(0)).expect("init must succeed");
    process_table.add_thread(thread);

    THE.initialize(Spinlock::new(process_table));
}

pub struct ProcessTable {
    threads: BTreeMap<Tid, ThreadRef>,
    children: BTreeMap<Tid, Vec<Tid>>,
    wait_wakers: Vec<Waker>,
}

impl ProcessTable {
    pub fn new() -> Self {
        Self {
            threads: BTreeMap::new(),
            children: BTreeMap::new(),
            wait_wakers: Vec::new(),
        }
    }

    pub fn add_thread(&mut self, thread: ThreadRef) {
        let (tid, parent_tid) = thread.with_lock(|t| (t.get_tid(), t.parent_tid()));
        LIVE_THREAD_COUNT.fetch_add(1, Ordering::Relaxed);
        RUN_QUEUE.lock().push_back(thread.clone());
        assert!(
            self.threads.insert(tid, thread).is_none(),
            "Duplicate TID {tid} in process table"
        );
        self.children.entry(parent_tid).or_default().push(tid);
    }

    pub fn get_highest_tid_without(&self, process_names: &[&str]) -> Option<Tid> {
        self.threads
            .iter()
            .filter(|(_, t)| {
                let t = t.lock();
                !matches!(t.get_state(), ThreadState::Zombie(_))
                    && !process_names.iter().any(|n| t.get_name() == *n)
                    && t.get_tid() != POWERSAVE_TID
            })
            .max_by_key(|(pid, _)| *pid)
            .map(|(pid, _)| *pid)
    }

    pub fn dump(&self) {
        for process in self.threads.values() {
            if process
                .try_with_lock(|p| {
                    info!("{}", *p);
                })
                .is_none()
            {
                info!("Cannot dump process because it is locked.");
            }
        }
    }

    pub fn take_zombie(&mut self, parent_tid: Tid, pid: i32) -> Option<(Tid, i32)> {
        let children = self.children.get(&parent_tid)?;

        let tid = if pid > 0 {
            let tid = Tid::try_from_i32(pid).expect("pid is positive");
            if !children.contains(&tid) {
                return None;
            }
            let is_zombie = self
                .threads
                .get(&tid)?
                .with_lock(|t| matches!(t.get_state(), ThreadState::Zombie(_)));
            if !is_zombie {
                return None;
            }
            tid
        } else {
            *children.iter().find(|&&child_tid| {
                self.threads.get(&child_tid).is_some_and(|t| {
                    t.with_lock(|t| matches!(t.get_state(), ThreadState::Zombie(_)))
                })
            })?
        };

        let thread = self.threads.remove(&tid).expect("tid was just found");
        let exit_code = thread.with_lock(|t| match t.get_state() {
            ThreadState::Zombie(code) => code,
            _ => unreachable!(),
        });

        if let Some(children) = self.children.get_mut(&parent_tid) {
            children.retain(|c| *c != tid);
        }
        self.children.remove(&tid);

        Some((tid, i32::from(exit_code) << 8))
    }

    pub fn has_any_child_of(&self, parent_tid: Tid) -> bool {
        self.children
            .get(&parent_tid)
            .is_some_and(|c| !c.is_empty())
    }

    pub fn register_wait_waker(&mut self, waker: Waker) {
        self.wait_wakers.push(waker);
    }

    fn wake_wait_wakers(&mut self) {
        for waker in self.wait_wakers.drain(..) {
            waker.wake();
        }
    }

    pub fn kill(&mut self, tid: Tid, exit_status: i32) {
        assert!(
            tid != POWERSAVE_TID,
            "We are not allowed to kill the never process"
        );
        debug!("Killing tid={tid}");
        let exit_code = u8::try_from(exit_status & 0xff).expect("masked to 8 bits");
        if let Some(thread) = self.threads.get(&tid).cloned() {
            LIVE_THREAD_COUNT.fetch_sub(1, Ordering::Relaxed);
            let main_tid = thread.with_lock(|mut t| {
                t.set_state(ThreadState::Zombie(exit_code));
                Cpu::current().ipi_to_all_but_me();

                if let Some(clear_child_tid) = t.get_clear_child_tid() {
                    let process = t.process();
                    let _ = clear_child_tid.write_with_process_lock(&process.lock(), 0);
                }

                if let Some(vfork_state) = t.take_vfork_state() {
                    vfork_state.lock().wake();
                }

                let process = t.process();
                process.lock().main_tid()
            });

            self.wake_wait_wakers();

            // Reparent orphans to init
            let init_tid = Tid::new(1);
            if let Some(orphans) = self.children.remove(&main_tid) {
                for &child_tid in &orphans {
                    if let Some(child_thread) = self.threads.get(&child_tid) {
                        child_thread.with_lock(|mut t| {
                            t.set_parent_tid(init_tid);
                        });
                    }
                }
                self.children.entry(init_tid).or_default().extend(orphans);
            }
        }
    }
}
